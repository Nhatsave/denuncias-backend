// src/auth/auth.service.ts
import { Injectable, BadRequestException, UnauthorizedException } from '@nestjs/common';
import { Repository } from 'typeorm';
import { InjectRepository } from '@nestjs/typeorm';
import * as bcrypt from 'bcrypt';
import { JwtService } from '@nestjs/jwt';
import {  CreateFuncionarioDto, CreateUserDto } from './dto/usuarioGeral.dto';
import { Funcionario, Pessoa, Usuario } from './entities/geral.entity';
import { FuncionarioResponseDto } from './dto/usuarioGeralResposta';

import * as jwt from 'jsonwebtoken';
 
  @Injectable()
export class AuthService {
  constructor(
    @InjectRepository(Usuario) private readonly usuarioRepo: Repository<Usuario>,
    @InjectRepository(Funcionario) private readonly funcionarioRepo: Repository<Funcionario>,
    @InjectRepository(Pessoa) private readonly pessoaRepo: Repository<Pessoa>,
    private readonly jwtService: JwtService,
  ) {}

  // Registro de usu√°rio comum
  async createUsuario(dto: CreateUserDto): Promise<Usuario> {

     // Verifica se j√° existe usu√°rio com o mesmo email
  const existingUser = await this.usuarioRepo.findOne({ where: { email: dto.email } });
  if (existingUser) {
    throw new BadRequestException('Email j√° cadastrado');
  }


    const pessoa = this.pessoaRepo.create({ ...dto });
    await this.pessoaRepo.save(pessoa);

    const senhaHash = await bcrypt.hash(dto.senha, 10);

    const usuario = this.usuarioRepo.create({
      pessoa,
      email: dto.email,
      residenciaAtual: dto.residenciaActual,
      senha: senhaHash,
    });

    return this.usuarioRepo.save(usuario);
  }

  // Registro de funcion√°rio
async createFuncionario(dto: CreateFuncionarioDto): Promise<FuncionarioResponseDto> {
     // Verifica se j√° existe funcion√°rio com o mesmo email
  const existingFuncionario = await this.funcionarioRepo.findOne({ where: { email: dto.email } });
  if (existingFuncionario) {
    throw new BadRequestException('Email j√° cadastrado');
  }
  
  // 1. Cria pessoa
  const pessoa = this.pessoaRepo.create({
    nome: dto.nome,
    apelido: dto.apelido,
    local_nascimento: dto.local_nascimento,
    data_nascimento: dto.data_nascimento,
    genero: dto.genero,
    contacto: dto.contacto,
  });
  await this.pessoaRepo.save(pessoa);

  // 2. Criptografa senha
  const senhaHash = await bcrypt.hash(dto.senha, 10);

  // 3. Cria funcion√°rio
  const funcionario = this.funcionarioRepo.create({
    pessoa,                 // rela√ß√£o OneToOne
    email: dto.email,
    senha: senhaHash,
    nip: dto.nip,
    categoria: dto.categoria,
    departamento: dto.departamento,
    perfil: dto.perfil || 'funcionario',
  });

  // 4. Salva no banco
 this.funcionarioRepo.save(funcionario);

   // 4. Retorna apenas os dados essenciais
  return {
    id_funcionario: funcionario.id_funcionario,
    email: funcionario.email,
    perfil: funcionario.perfil,
    nome: pessoa.nome,
    apelido: pessoa.apelido,
    contacto: pessoa.contacto,
    estado: "Cadastro feito com sucesso"
  };
}

// src/auth/auth.service.ts - CORRIJA O LOGIN
async login(email: string, senha: string) {
  const usuario = await this.validateUser(email, senha);
  if (!usuario) throw new UnauthorizedException('Email ou senha incorretos');

  // PAYLOAD SIMPLIFICADO E CONSISTENTE
  const payload = {
    sub: usuario.id_usuario,     // ‚Üê ID do usu√°rio
    email: usuario.email,
    tipo: 'usuario',
    nome: usuario.pessoa?.nome,
    // N√ÉO inclua 'roles' se n√£o est√° usando
  };

  console.log('üîê Gerando token com payload:', payload);

  const access_token = this.jwtService.sign(payload);
  
  const refresh_token = this.jwtService.sign(
    { sub: usuario.id_usuario, type: 'refresh' },
    { expiresIn: '7d' }
  );

  return {
    access_token,
    refresh_token,
    expires_in: 3600,
    usuario: {
      id_usuario: usuario.id_usuario,
      email: usuario.email,
      nome: usuario.pessoa?.nome,
    },
  };
}

 async loginFuncionario(nip: string, senha: string) {
  const funcionario = await this.validateUserFuncionario(nip, senha);
  if (!funcionario) throw new UnauthorizedException('Email ou senha incorretos');

  const access_token = this.generateAccessToken(funcionario);
  const refresh_token = this.generateRefreshToken(funcionario);

    const payload = {
    sub: funcionario.id_funcionario, // üî¥ ID do funcion√°rio
    tipo: 'funcionario',
    email: funcionario.email,
    roles: [funcionario.perfil], // admin | monitor | agente
  };

  return {
    access_token: this.jwtService.sign(payload),
    refresh_token,
    expires_in: 3600,
    usuario: {
      id_usuario: funcionario.id_usuario,
      email: funcionario.email,
      nome: funcionario.pessoa?.nome,
    },
  };
}
 
 
// Renova o token usando refresh token
 async refreshToken(oldRefreshToken: string) {
  try {
    // Usa verifyAsync para verifica√ß√£o ass√≠ncrona
    const payload = await this.jwtService.verifyAsync(oldRefreshToken);
    
    if (payload.type !== 'refresh') {
      throw new UnauthorizedException('Tipo de token inv√°lido');
    }

    // Busca o usu√°rio no banco para verificar se ainda existe
    const usuario = await this.usuarioRepo.findOne({
      where: { id_usuario: payload.sub },
      relations: ['pessoa'],
    });

    if (!usuario) {
      throw new UnauthorizedException('Usu√°rio n√£o encontrado');
    }

    // Verifica se o email ainda √© o mesmo (seguran√ßa extra)
    if (usuario.email !== payload.email) {
      throw new UnauthorizedException('Credenciais inv√°lidas');
    }

    // Gera novos tokens
    const access_token = await this.generateAccessToken(usuario);
    const refresh_token = await this.generateRefreshToken(usuario);

    return {
      access_token,
      refresh_token,
      expires_in: 3600, // 1 hora
      token_type: 'Bearer',
    };
  } catch (error) {
    // Log do erro para debug (opcional)
    console.error('Erro no refresh token:', error.message);
    
    if (error.name === 'JsonWebTokenError' || error.name === 'TokenExpiredError') {
      throw new UnauthorizedException('Refresh token inv√°lido ou expirado');
    }
    throw error;
  }
}

 /*
  async validateUser(email: string, senha: string): Promise<Usuario | null> {
    const user = await this.usuarioRepo.findOne({
      where: { email },
      relations: ['pessoa'],
    });

    if (user && (await bcrypt.compare(senha, user.senha))) {
      return user;
    }
    return null;
  }

  // Gera token de acesso
  private async generateAccessToken(usuario: Usuario): Promise<string> {
    const payload = { 
      sub: usuario.id_usuario, 
      email: usuario.email,
      type: 'access'
    };
    
    return this.jwtService.sign(payload);
  }

  // Gera refresh token
  private async generateRefreshToken(usuario: Usuario): Promise<string> {
    const payload = { 
      sub: usuario.id_usuario, 
      email: usuario.email,
      type: 'refresh'
    };
    
    return this.jwtService.sign(payload, {
      expiresIn: '7d', // Refresh token vale por 7 dias
    });
  }

  // Renova o token usando refresh token
 async refreshToken(oldRefreshToken: string) {
  try {
    // Usa verifyAsync para verifica√ß√£o ass√≠ncrona
    const payload = await this.jwtService.verifyAsync(oldRefreshToken);
    
    if (payload.type !== 'refresh') {
      throw new UnauthorizedException('Tipo de token inv√°lido');
    }

    // Busca o usu√°rio no banco para verificar se ainda existe
    const usuario = await this.usuarioRepo.findOne({
      where: { id_usuario: payload.sub },
      relations: ['pessoa'],
    });

    if (!usuario) {
      throw new UnauthorizedException('Usu√°rio n√£o encontrado');
    }

    // Verifica se o email ainda √© o mesmo (seguran√ßa extra)
    if (usuario.email !== payload.email) {
      throw new UnauthorizedException('Credenciais inv√°lidas');
    }

    // Gera novos tokens
    const access_token = await this.generateAccessToken(usuario);
    const refresh_token = await this.generateRefreshToken(usuario);

    return {
      access_token,
      refresh_token,
      expires_in: 3600, // 1 hora
      token_type: 'Bearer',
    };
  } catch (error) {
    // Log do erro para debug (opcional)
    console.error('Erro no refresh token:', error.message);
    
    if (error.name === 'JsonWebTokenError' || error.name === 'TokenExpiredError') {
      throw new UnauthorizedException('Refresh token inv√°lido ou expirado');
    }
    throw error;
  }
}

  // Valida token (para usar em guards)
  async validateToken(token: string) {
    try {
      return this.jwtService.verify(token);
    } catch (error) {
      return null;
    }
  }

  */
 /**
   * Valida email e senha do usu√°rio
   */
  private async validateUser(email: string, senha: string): Promise<any> {
    const usuario = await this.usuarioRepo.findOne({
      where: { email },
      relations: ['pessoa'],
    });

    if (!usuario) return null;

    // Compare senha (ajuste conforme seu hash)
    const senhaValida = await bcrypt.compare(senha, usuario.senha);
    return senhaValida ? usuario : null;
  }

   private async validateUserFuncionario(nip: string, senha: string): Promise<any> {
    const usuario = await this.funcionarioRepo.findOne({
      where: { nip },
      relations: ['pessoa'],
    });

    if (!usuario) return null;

    // Compare senha (ajuste conforme seu hash)
    const senhaValida = await bcrypt.compare(senha, usuario.senha);
    return senhaValida ? usuario : null;
  }

  private generateAccessToken(usuario: any): string { // ‚Üê Deve retornar STRING
  const payload = {
    sub: usuario.id_usuario,
    email: usuario.email,
    nome: usuario.pessoa?.nome || usuario.nome,
    roles: usuario.roles || ['user'],
  };

  // Retorna a STRING do token, n√£o um objeto
  return this.jwtService.sign(payload, {
    expiresIn: '1h',
    secret: process.env.JWT_SECRET || 'secreto-dev',
  });
}

private generateRefreshToken(usuario: any): string { // ‚Üê Deve retornar STRING
  const payload = {
    sub: usuario.id_usuario,
    type: 'refresh',
  };

  // Retorna a STRING do token
  return this.jwtService.sign(payload, {
    expiresIn: '7d',
    secret: process.env.JWT_REFRESH_SECRET || process.env.JWT_SECRET || 'refresh-secreto',
  });
}
}